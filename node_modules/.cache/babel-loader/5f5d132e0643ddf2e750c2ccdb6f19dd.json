{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","patternLikeCommon","functionTypeAnnotationCommon","functionDeclarationCommon","functionCommon","classMethodOrPropertyCommon","classMethodOrDeclareMethodCommon","_is","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","defineType","defineAliasedType","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","params","generator","async","returnType","declare","id","predicate","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","validateOptional","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","importKind","accessibility","static","override","access","tag","quasi","assertShape","raw","cooked","tail","quasis","delegate","assertOptionalChainStart","readonly","variance"],"sources":["/Users/docfrawley/Sites/NVoge/srsite/node_modules/@babel/types/lib/definitions/core.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}