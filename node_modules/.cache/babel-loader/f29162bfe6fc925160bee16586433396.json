{"ast":null,"code":"import \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\n\nvar instanceOfAny = function instanceOfAny(object, constructors) {\n  return constructors.some(function (c) {\n    return object instanceof c;\n  });\n};\n\nvar idbProxyableTypes;\nvar cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype[\"continue\"], IDBCursor.prototype.continuePrimaryKey]);\n}\n\nvar cursorRequestMap = new WeakMap();\nvar transactionDoneMap = new WeakMap();\nvar transactionStoreNamesMap = new WeakMap();\nvar transformCache = new WeakMap();\nvar reverseTransformCache = new WeakMap();\n\nfunction promisifyRequest(request) {\n  var promise = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    var success = function success() {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    var error = function error() {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(function (value) {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  })[\"catch\"](function () {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  var done = new Promise(function (resolve, reject) {\n    var unlisten = function unlisten() {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    var complete = function complete() {\n      resolve();\n      unlisten();\n    };\n\n    var error = function error() {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nvar idbProxyTraps = {\n  get: function get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n  set: function set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has: function has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n};\n\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var tx = func.call.apply(func, [unwrap(this), storeNames].concat(args));\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  var newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nvar unwrap = function unwrap(value) {\n  return reverseTransformCache.get(value);\n};\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","map":{"version":3,"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","storeNames","args","call","unwrap","sort","includes","apply","transformCachableValue","Proxy","IDBRequest","newValue","a","i","r","u","w"],"sources":["/Users/mattfrawley/sites/srsite/node_modules/idb/build/wrap-idb-value.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}